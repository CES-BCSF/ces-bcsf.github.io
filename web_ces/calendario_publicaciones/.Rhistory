datos <- readxl::read_excel("C:/Users/franc/Downloads/petroleo.xlsx")
attach(datos)
PETROLEO <- ts(datos$USD_Barrel, frequency = 12, start = c(1960, 1), end = c(2025, 5))
# PETROLEO <- stats::ts(ICASFE, frequency = 12, start = base::c(2010,01), end = base::c(2025,03))
#Grafico la serie y analizo
stats::ts.plot(PETROLEO)
stats::ts.plot(diff(PETROLEO))
PETROLEO.int <- diff(PETROLEO)
## TEST DICKEY-FULLER AUMENTADO (ADF) ####
## TEST DE RAIZ UNITARIA
### TEST CON PAQUETE TSERIES ####
# LA FUNCION adf.test GENERA UN "ADF DE REGRESION" | VERSION SIMPLE DEL TEST ADF
# VALOR P CERCANO A CERO IMPLICA SERIE ESTACIONARIA (NECESARIO PARA MODELAR)
#PRUEBA
tseries::adf.test(stats::na.omit(PETROLEO))
tseries::adf.test(stats::na.omit(PETROLEO.int))
adf.PETROLEO <- urca::ur.df(y=stats::na.omit(PETROLEO), type='none')
urca::summary(adf.PETROLEO)
## DATOS ####
datos <- readxl::read_excel("C:/Users/franc/Downloads/petroleo.xlsx")
attach(datos)
PETROLEO <- ts(datos$USD_Barrel, frequency = 12, start = c(1960, 1), end = c(2025, 5))
# PETROLEO <- stats::ts(ICASFE, frequency = 12, start = base::c(2010,01), end = base::c(2025,03))
#Grafico la serie y analizo
stats::ts.plot(PETROLEO)
stats::ts.plot(diff(PETROLEO))
PETROLEO.int <- diff(PETROLEO)
## TEST DICKEY-FULLER AUMENTADO (ADF) ####
## TEST DE RAIZ UNITARIA
### TEST CON PAQUETE TSERIES ####
# LA FUNCION adf.test GENERA UN "ADF DE REGRESION" | VERSION SIMPLE DEL TEST ADF
# VALOR P CERCANO A CERO IMPLICA SERIE ESTACIONARIA (NECESARIO PARA MODELAR)
#PRUEBA
tseries::adf.test(stats::na.omit(PETROLEO))
tseries::adf.test(stats::na.omit(PETROLEO.int))
adf.PETROLEO <- urca::ur.df(y=stats::na.omit(PETROLEO), type='none')
urca::summary(adf.PETROLEO)
adf.PETROLEOINT <- urca::ur.df(y=stats::na.omit(PETROLEO.int), type='none')
urca::summary(adf.PETROLEOINT)
# trabajo directamente sobre las diferencias
graphics::par(mfrow = base::c(1, 2))  # 2 FILAS Y 1 COLUMNA PARA ACF Y PACF EN UN SOLO PANEL
stats::acf(na.omit(PETROLEO.int),lag.max = 60, ylim = c(-1, 1))
stats::pacf(na.omit(PETROLEO.int),lag.max = 60, ylim = c(-1, 1))
#ANALIZO AUTOCORRELOGRAMAS EN LA PARTE ESTACIONAL
ICA_seasonal <- diff(ICA, lag = 12)  # Diferenciación estacional
#ANALIZO AUTOCORRELOGRAMAS EN LA PARTE ESTACIONAL
PETROLEO_seasonal <- diff(PETROLEO, lag = 12)  # Diferenciación estacional
acf(PETROLEO_seasonal, lag.max = 48, ylim = c(-1, 1))
pacf(PETROLEO_seasonal, lag.max = 48, ylim = c(-1, 1))
# ARIMA(2,0,0) estacional?
PETROLEO_seasonal <- diff(PETROLEO, lag = 12)  # Diferenciación estacional
acf(PETROLEO_seasonal, lag.max = 48, ylim = c(-1, 1))
pacf(PETROLEO_seasonal, lag.max = 48, ylim = c(-1, 1))
# ARIMA(2,0,0) estacional?
PETROLEO_seasonal_int <- diff(PETROLEO_seasonal)  # d=1 y D=1
acf(PETROLEO_seasonal_int, lag.max = 48, ylim = c(-1, 1))
pacf(PETROLEO_seasonal_int, lag.max = 48, ylim = c(-1, 1))
# podemos proponer un ARIMA(1,1,0) estacional
## DATOS ####
datos <- readxl::read_excel("C:/Users/franc/Downloads/petroleo.xlsx")
attach(datos)
PETROLEO <- ts(datos$USD_Barrel, frequency = 12, start = c(1960, 1), end = c(2025, 5))
# PETROLEO <- stats::ts(ICASFE, frequency = 12, start = base::c(2010,01), end = base::c(2025,03))
#Grafico la serie y analizo
stats::ts.plot(PETROLEO)
stats::ts.plot(diff(PETROLEO))
PETROLEO.int <- diff(PETROLEO)
## TEST DICKEY-FULLER AUMENTADO (ADF) ####
## TEST DE RAIZ UNITARIA
### TEST CON PAQUETE TSERIES ####
# LA FUNCION adf.test GENERA UN "ADF DE REGRESION" | VERSION SIMPLE DEL TEST ADF
# VALOR P CERCANO A CERO IMPLICA SERIE ESTACIONARIA (NECESARIO PARA MODELAR)
#PRUEBA
tseries::adf.test(stats::na.omit(PETROLEO))
tseries::adf.test(stats::na.omit(PETROLEO.int))
adf.PETROLEO <- urca::ur.df(y=stats::na.omit(PETROLEO), type='none')
urca::summary(adf.PETROLEO)
adf.PETROLEOINT <- urca::ur.df(y=stats::na.omit(PETROLEO.int), type='none')
urca::summary(adf.PETROLEOINT)
# trabajo directamente sobre las diferencias
graphics::par(mfrow = base::c(1, 2))  # 2 FILAS Y 1 COLUMNA PARA ACF Y PACF EN UN SOLO PANEL
stats::acf(na.omit(PETROLEO.int),lag.max = 60, ylim = c(-1, 1))
stats::pacf(na.omit(PETROLEO.int),lag.max = 60, ylim = c(-1, 1))
#ANALIZO AUTOCORRELOGRAMAS EN LA PARTE ESTACIONAL
PETROLEO_seasonal <- diff(PETROLEO, lag = 12)  # Diferenciación estacional
acf(PETROLEO_seasonal, lag.max = 48, ylim = c(-1, 1))
pacf(PETROLEO_seasonal, lag.max = 48, ylim = c(-1, 1))
# ARIMA(2,0,0) estacional?
PETROLEO_seasonal_int <- diff(PETROLEO_seasonal)  # d=1 y D=1
acf(PETROLEO_seasonal_int, lag.max = 48, ylim = c(-1, 1))
pacf(PETROLEO_seasonal_int, lag.max = 48, ylim = c(-1, 1))
# podemos proponer un ARIMA(1,1,0) estacional
gc()
library(readxl)
Ventas_de_supermercados_de_la_provincia_Santa_Fe_grandes_superficies <- read_excel("C:/Users/franc/OneDrive - UTN - Santa Fe/Documents/2025/BCSF/CursoST/Ventas de supermercados de la provincia Santa Fe, grandes superficies.xlsx")
View(Ventas_de_supermercados_de_la_provincia_Santa_Fe_grandes_superficies)
library(readxl)
datos <- read_excel("C:/Users/franc/OneDrive - UTN - Santa Fe/Documents/2025/BCSF/CursoST/TP-Clase 6/SFE-REC.xlsx")
library(readxl)
datos <- read_excel("C:\Users\franc\OneDrive - UTN - Santa Fe\Documents\2025\BCSF\CursoST\TP-Clase 6\SFE-REC.xlsx")
datos <- readxl::read_excel("C:\Users\franc\OneDrive - UTN - Santa Fe\Documents\2025\BCSF\CursoST\TP-Clase 6\SFE-REC.xlsx")
datos <- readxl::read_excel("D:/TP-Clase 6/SFE-REC.xlsx")
attach(datos)
RECAUDACION <- ts(datos$SFE_REC, frequency = 12, start = c(1992, 1))
#Imprimir la serie
ts.plot(RECAUDACION, main = "Serie de Recaudación - Precios Constantes", ylab = "Millones de pesos 1993")
w
# Últimos 10 años (2015–2025):
window(RECAUDACION, start = c(2015, 1)) |> ts.plot(main = "Últimos 10 años", ylab = "Millones de pesos 1993")
# Últimos 1 años (2015–2025):
window(RECAUDACION, start = c(2024, 3)) |> ts.plot(main = "Último año", ylab = "Millones de pesos 1993")
# Últimos 1 años (2015–2025):
window(RECAUDACION, start = c(2020, 3)) |> ts.plot(main = "Último año", ylab = "Millones de pesos 1993")
#¿como observo estacionalidad?
meses <- c("Ene", "Feb", "Mar", "Abr", "May", "Jun",
"Jul", "Ago", "Sep", "Oct", "Nov", "Dic")
boxplot(RECAUDACION ~ cycle(RECAUDACION), main = "Boxplot estacional",
xlab = "Mes", ylab = "Valor", names = meses)
forecast::ggseasonplot(RECAUDACION)
#Cargo los datos
datos <- readxl::read_excel("D:/TP-Clase 6/SFE-REC.xlsx")
attach(datos)
#cargo en la variable la serie de tiempo
RECAUDACION <- ts(datos$SFE_REC, frequency = 12, start = c(1992, 1))
#Imprimir la serie (plot)
ts.plot(RECAUDACION, main = "Serie de Recaudación - Precios Constantes", ylab = "Millones de pesos 1993")
#Realizar primera diferencia e imprimirla
RECAUDACION.int <- diff(RECAUDACION)
stats::ts.plot(RECAUDACION.int)
#Realizar primera diferencia e imprimirla
RECAUDACION.int2 <- diff(RECAUDACION.int)
stats::ts.plot(RECAUDACION.int2)
#Cargo los datos
datos <- readxl::read_excel("D:/TP-Clase 6/SFE-REC.xlsx")
attach(datos)
#cargo en la variable la serie de tiempo
RECAUDACION <- ts(datos$SFE_REC, frequency = 12, start = c(1992, 1))
#Imprimir la serie (plot)
ts.plot(RECAUDACION, main = "Serie de Recaudación - Precios Constantes", ylab = "Millones de pesos 1993")
#Realizar primera diferencia e imprimirla
RECAUDACION.int <- diff(RECAUDACION)
ts.plot(RECAUDACION.int, main = "Serie de Recaudación - Precios Constantes", ylab = "Millones de pesos 1993")
# Últimos 1 años (2015–2025):
window(RECAUDACION, start = c(2020, 3)) |> ts.plot(main = "Último año", ylab = "Millones de pesos 1993")
#¿como observo estacionalidad?
#Realizo el Boxplot para ver Estacionalidad
meses <- c("Ene", "Feb", "Mar", "Abr", "May", "Jun",
"Jul", "Ago", "Sep", "Oct", "Nov", "Dic")
boxplot(RECAUDACION ~ cycle(RECAUDACION), main = "Boxplot estacional",
xlab = "Mes", ylab = "Valor", names = meses)
forecast::ggseasonplot(RECAUDACION)
#Cargo los datos
datos <- readxl::read_excel("D:/TP-Clase 6/SFE-REC.xlsx")
attach(datos)
#cargo en la variable la serie de tiempo
RECAUDACION <- ts(datos$SFE_REC, frequency = 12, start = c(1992, 1))
#Imprimir la serie (plot)
ts.plot(RECAUDACION, main = "Serie de Recaudación - Precios Constantes", ylab = "Millones de pesos 1993")
#Realizar primera diferencia e imprimirla
RECAUDACION.int <- diff(RECAUDACION)
ts.plot(RECAUDACION.int, main = "Serie de Recaudación - Precios Constantes", ylab = "Millones de pesos 1993")
# Últimos 1 años (2015–2025):
window(RECAUDACION, start = c(2020, 3)) |> ts.plot(main = "Último año", ylab = "Millones de pesos 1993")
#¿como observo estacionalidad?
#Realizo el Boxplot para ver Estacionalidad
meses <- c("Ene", "Feb", "Mar", "Abr", "May", "Jun",
"Jul", "Ago", "Sep", "Oct", "Nov", "Dic")
boxplot(RECAUDACION ~ cycle(RECAUDACION), main = "Boxplot estacional",
xlab = "Mes", ylab = "Valor", names = meses)
forecast::ggseasonplot(RECAUDACION)
adf.RECAUDACION <- urca::ur.df(y=stats::na.omit(RECAUDACION), type='none')
urca::summary(adf.RECAUDACION)
adf.dRECAUDACION <- urca::ur.df(y=stats::na.omit(RECAUDACION.int), type='none')
urca::summary(adf.dRECAUDACION)
### FUNCIONES DE AUTOCORRELACION ####
# trabajo directamente sobre las diferencias
graphics::par(mfrow = base::c(1, 2))  # 2 FILAS Y 1 COLUMNA PARA ACF Y PACF EN UN SOLO PANEL
stats::acf(na.omit(ICA.int),lag.max = 60, ylim = c(-1, 1))
# trabajo directamente sobre las diferencias
graphics::par(mfrow = base::c(1, 2))  # 2 FILAS Y 1 COLUMNA PARA ACF Y PACF EN UN SOLO PANEL
stats::acf(na.omit(RECAUDACION.int),lag.max = 60, ylim = c(-1, 1))
stats::pacf(na.omit(RECAUDACION.int),lag.max = 60, ylim = c(-1, 1))
recaudacion.114.114 <- forecast::Arima(RECAUDACION, order = c(1, 1, 4),
seasonal = list(order = c(1, 1, 4)))
summary(recaudacion.114.114)
lmtest::coeftest(recaudacion.114.114)
forecast::checkresiduals(recaudacion.110.110)
recaudacion.114.114 <- forecast::Arima(RECAUDACION, order = c(1, 1, 4),
seasonal = list(order = c(1, 1, 4)))
summary(recaudacion.114.114)
#Cargo los datos
datos <- readxl::read_excel("D:/TP-Clase 6/SFE-REC.xlsx")
attach(datos)
#cargo en la variable la serie de tiempo
RECAUDACION <- ts(datos$SFE_REC, frequency = 12, start = c(1992, 1))
#Imprimir la serie (plot)
ts.plot(RECAUDACION, main = "Serie de Recaudación - Precios Constantes", ylab = "Millones de pesos 1993")
#Realizar primera diferencia e imprimirla
RECAUDACION.int <- diff(RECAUDACION)
ts.plot(RECAUDACION.int, main = "Serie de Recaudación - Precios Constantes", ylab = "Millones de pesos 1993")
# Últimos 1 años (2015–2025):
window(RECAUDACION, start = c(2020, 3)) |> ts.plot(main = "Último año", ylab = "Millones de pesos 1993")
#¿como observo estacionalidad?
#Realizo el Boxplot para ver Estacionalidad
meses <- c("Ene", "Feb", "Mar", "Abr", "May", "Jun",
"Jul", "Ago", "Sep", "Oct", "Nov", "Dic")
boxplot(RECAUDACION ~ cycle(RECAUDACION), main = "Boxplot estacional",
xlab = "Mes", ylab = "Valor", names = meses)
forecast::ggseasonplot(RECAUDACION)
#2 Differencia 1 saca tendencia, differencia 2 Saca Estacional
## TEST DICKEICA## TEST DICKEY-FULLER AUMENTADO (ADF) ####
## TEST DE RAIZ UNITARIA
### TEST CON PAQUETE URCA ####
# ALTERNATIVA MAS CORRECTA DEL TEST
# PERMITE DIFERENTES ESPECIFICACIONES
# HO = EXISTE RAIZ UNITARIA | SI RECHAZO => ESTACIONARIA
# PARA RECHAZAR tau1,DEBE SER MENOR A LOS VALORES EXPUESTOS EN 1pct, 5pct, 10pct
adf.RECAUDACION <- urca::ur.df(y=stats::na.omit(RECAUDACION), type='none')
urca::summary(adf.RECAUDACION)
#No rechazo H0 -> NO ESTACIONARIA
adf.dRECAUDACION <- urca::ur.df(y=stats::na.omit(RECAUDACION.int), type='none')
urca::summary(adf.dRECAUDACION)
#RECHAZO H0 -> ESTACIONARIA
### FUNCIONES DE AUTOCORRELACION ####
# trabajo directamente sobre las diferencias
graphics::par(mfrow = base::c(1, 2))  # 2 FILAS Y 1 COLUMNA PARA ACF Y PACF EN UN SOLO PANEL
stats::acf(na.omit(RECAUDACION.int),lag.max = 60, ylim = c(-1, 1))
stats::pacf(na.omit(RECAUDACION.int),lag.max = 60, ylim = c(-1, 1))
# a priori podemos proponer un AR(1), pero hay un componente estacional que hace ruido
source("C:/Users/franc/OneDrive/Escritorio/TP.R", echo = TRUE)
#Cargo los datos
datos <- readxl::read_excel("D:/TP-Clase 6/SFE-REC.xlsx")
attach(datos)
#cargo en la variable la serie de tiempo
RECAUDACION <- ts(datos$SFE_REC, frequency = 12, start = c(1992, 1))
#Imprimir la serie (plot)
ts.plot(RECAUDACION, main = "Serie de Recaudación - Precios Constantes", ylab = "Millones de pesos 1993")
#Realizar primera diferencia e imprimirla
RECAUDACION.int <- diff(RECAUDACION)
ts.plot(RECAUDACION.int, main = "Serie de Recaudación - Precios Constantes", ylab = "Millones de pesos 1993")
# Últimos 1 años (2015–2025):
window(RECAUDACION, start = c(2020, 3)) |> ts.plot(main = "Último año", ylab = "Millones de pesos 1993")
#¿como observo estacionalidad?
#Realizo el Boxplot para ver Estacionalidad
meses <- c("Ene", "Feb", "Mar", "Abr", "May", "Jun",
"Jul", "Ago", "Sep", "Oct", "Nov", "Dic")
boxplot(RECAUDACION ~ cycle(RECAUDACION), main = "Boxplot estacional",
xlab = "Mes", ylab = "Valor", names = meses)
forecast::ggseasonplot(RECAUDACION)
#2 Differencia 1 saca tendencia, differencia 2 Saca Estacional
## TEST DICKEICA## TEST DICKEY-FULLER AUMENTADO (ADF) ####
## TEST DE RAIZ UNITARIA
### TEST CON PAQUETE URCA ####
# ALTERNATIVA MAS CORRECTA DEL TEST
# PERMITE DIFERENTES ESPECIFICACIONES
# HO = EXISTE RAIZ UNITARIA | SI RECHAZO => ESTACIONARIA
# PARA RECHAZAR tau1,DEBE SER MENOR A LOS VALORES EXPUESTOS EN 1pct, 5pct, 10pct
adf.RECAUDACION <- urca::ur.df(y=stats::na.omit(RECAUDACION), type='none')
urca::summary(adf.RECAUDACION)
#No rechazo H0 -> NO ESTACIONARIA
adf.dRECAUDACION <- urca::ur.df(y=stats::na.omit(RECAUDACION.int), type='none')
urca::summary(adf.dRECAUDACION)
#RECHAZO H0 -> ESTACIONARIA
## MODELADO ICASFE ####
### FUNCIONES DE AUTOCORRELACION ####
# trabajo directamente sobre las diferencias
graphics::par(mfrow = base::c(1, 2))  # 2 FILAS Y 1 COLUMNA PARA ACF Y PACF EN UN SOLO PANEL
stats::acf(na.omit(RECAUDACION.int),lag.max = 60, ylim = c(-1, 1))
stats::pacf(na.omit(RECAUDACION.int),lag.max = 60, ylim = c(-1, 1))
# a priori podemos proponer un AR(1), pero hay un componente estacional que hace ruido
#ANALIZO AUTOCORRELOGRAMAS EN LA PARTE ESTACIONAL
RECAUDACION_seasonal <- diff(RECAUDACION, lag = 12)  # Diferenciación estacional
acf(RECAUDACION_seasonal, lag.max = 48, ylim = c(-1, 1))
pacf(RECAUDACION_seasonal, lag.max = 48, ylim = c(-1, 1))
# ARIMA(2,0,0) estacional?
RECAUDACION_seasonal_int <- diff(RECAUDACION_seasonal)  # d=1 y D=1
acf(RECAUDACION_seasonal_int, lag.max = 48, ylim = c(-1, 1))
pacf(RECAUDACION_seasonal_int, lag.max = 48, ylim = c(-1, 1))
RECAUDACION_seasonal_int <- diff(RECAUDACION_seasonal)  # d=1 y D=1
acf(RECAUDACION_seasonal_int, lag.max = 48, ylim = c(-1, 1))
pacf(RECAUDACION_seasonal_int, lag.max = 48, ylim = c(-1, 1))
# podemos proponer un ARIMA(0,1,1) estacional
### MODELOS SARIMA ####
recaudacion.110.110 <- forecast::Arima(RECAUDACION_seasonal, order = c(1, 1, 0),
seasonal = list(order = c(1, 1, 0)))
summary(recaudacion.110.110)
forecast::checkresiduals(recaudacion.110.110)
# trabajo directamente sobre niveles
graphics::par(mfrow = base::c(1, 2))  # 2 FILAS Y 1 COLUMNA PARA ACF Y PACF EN UN SOLO PANEL
stats::acf(na.omit(RECAUDACION),lag.max = 60, ylim = c(-1, 1))
stats::pacf(na.omit(RECAUDACION),lag.max = 60, ylim = c(-1, 1))
graphics::par(mfrow = base::c(1, 2))  # 2 FILAS Y 1 COLUMNA PARA ACF Y PACF EN UN SOLO PANEL
stats::acf(na.omit(RECAUDACION),lag.max =48, ylim = c(-1, 1))
stats::pacf(na.omit(RECAUDACION),lag.max = 48, ylim = c(-1, 1))
#### CONFIGURACIÓN DE PATH ####
path_0 <- getwd()
setwd("C:/mysyncfolders/bcsf.com.ar/BCSF - Grupo CES - Documentos/CicSFE_sp/_Reportes rmd/calendario_publicaciones")
### FUNCIONES ####
limpiar_widget_html <- function(path_in, path_out) {
frag <- readLines(path_in, warn = FALSE)
# 1) Líneas globales a eliminar siempre
patrones_basura <- c(
"<!DOCTYPE", "<html", "</html>", "<head>", "</head>",
"<body>", "</body>", "<meta", "<style", "</style>", "<title>", "</title>"
)
frag <- frag[!grepl(paste(patrones_basura, collapse = "|"), frag)]
# 2) Detectar el bloque htmlwidget_container
idx_open <- grep('<div id="htmlwidget_container">', frag)
if (length(idx_open) == 1) {
# 2A) buscar el cierre real (primer </div> después de la apertura)
idx_after <- (idx_open + 1):length(frag)
idx_close_rel <- grep("^\\s*</div>\\s*$", frag[idx_after])
if (length(idx_close_rel) > 0) {
idx_close <- idx_after[idx_close_rel[1]]
# 3) Antes de borrar, rescatamos los div internos
bloque <- frag[(idx_open + 1):(idx_close - 1)]
# 4) Eliminamos todo el bloque externo
frag <- frag[-(idx_open:idx_close)]
# 5) Insertamos solo las líneas internas donde estaba el bloque
# (primero insertamos, luego hacemos limpieza de indices)
frag <- append(frag, bloque, after = idx_open - 1)
}
else {
# Si no encuentra cierre, solo borra apertura (fallback seguro)
frag <- frag[-idx_open]
}
}
# 4) Borrar scripts inline basura de htmlwidgets pero NO bibliotecas
frag <- frag[!grepl("^<script>.*htmlwidgets.*</script>$", frag)]
# 5) Limpieza final de líneas vacías
frag <- frag[nchar(trimws(frag)) > 0]
# 6) Guardar
writeLines(frag, path_out)
message("[OK] Widget limpiado y guardado en: ", path_out)
}
volver_al_indice <- paste('<div class="back-to-index-container">
<a href="#ref_notas" class="back-to-index-btn">
<span class="btn-icon">↑</span>
<span class="btn-text">Volver al índice</span>
</a>
</div>')
#### INPUT DATOS ####
df_calendario <- readxl::read_excel("C:/mysyncfolders/bcsf.com.ar/BCSF - Grupo CES - Documentos/CicSFE_sp/Seguimiento Manual.xlsx", range = "OUT_Calendario!B2:I300", col_names = TRUE)
#### LIMPIEZA DE DATOS ####
df_limpio <- df_calendario |>
dplyr::filter(!base::is.na(`Categoría`) & `Categoría` != "") |>
dplyr::mutate(
`Último dato` = stringr::str_squish(`Último dato`)
) |>
dplyr::mutate(
`Fecha de publicación conocida` = dplyr::case_when(
suppressWarnings(!base::is.na(base::as.numeric(`Fecha de publicación conocida`))) ~ base::as.Date(base::as.numeric(`Fecha de publicación conocida`), origin = "1899-12-30"),
suppressWarnings(!base::is.na(lubridate::dmy(`Fecha de publicación conocida`))) ~ lubridate::dmy(`Fecha de publicación conocida`),
TRUE ~ lubridate::NA_Date_
),
`Fecha de publicación estimada` = dplyr::case_when(
suppressWarnings(!base::is.na(base::as.numeric(`Fecha de publicación estimada`))) ~ format(base::as.Date(base::as.numeric(`Fecha de publicación estimada`), origin = "1899/12/30"), "%d/%m/%Y"),
suppressWarnings(!base::is.na(lubridate::dmy(`Fecha de publicación estimada`))) ~ format(lubridate::dmy(`Fecha de publicación estimada`), "%d/%m/%Y"),
TRUE ~ as.character(`Fecha de publicación estimada`)
),
year = base::as.integer(stringr::str_extract(`Último dato`, "^\\d{4}")),
segundo_str = dplyr::if_else(
`Frecuencia` == 'Mensual',
base::as.integer(stringr::str_extract(`Último dato`, "(?<=,)\\d+")),
(dplyr::if_else(
`Frecuencia` == "Trimestral" | `Frecuencia` == "Semestral",
base::as.integer(stringr::str_extract(`Último dato`, "(?<=,)\\d+")),
NA_integer_)
)
),
month = dplyr::case_when(
`Frecuencia` == "Censal" ~ 1L,
`Frecuencia` == "Anual" ~ 1L,
`Frecuencia` == "Mensual" ~ segundo_str,
`Frecuencia` == "Trimestral" ~ segundo_str * 3L,
`Frecuencia` == "Semestral" ~ segundo_str * 6L,
TRUE ~ NA_integer_
),
orden_fecha = year * 100 + month,
`Último dato` = orden_fecha #UNA VEZ ESTABILIZADO EL CALENDARIO REEMPLAZAR LA LOGICA DE ORDEN DE FECHA PARA ULTIMO DATO ASI SE LIBERA DE CREAR UNA COLUMNA REDUNDANTE
)
#### FILTROS ####
shared_df <- crosstalk::SharedData$new(df_limpio)
filtros <- htmltools::tagList(
htmltools::div(class = "row",
htmltools::div(class = "col-sm-4",
crosstalk::filter_select("Categoría", "Categoría", shared_df, ~`Categoría`)
),
htmltools::div(class = "col-sm-4",
crosstalk::filter_select("Fuente", "Fuente", shared_df, ~Fuente)
),
htmltools::div(class = "col-sm-4",
crosstalk::filter_select("Alcance geográfico", "Alcance geográfico", shared_df, ~`Alcance geográfico`)
)
)
)
htmltools::save_html(
filtros,
file = "filtros.html",
background = "transparent"
)
limpiar_widget_html("filtros.html", "filtros.html")
#### TABLA INTERACTIVA (DEFINICION Y EXPORTACION) ####
idx_frecuencia <- which(colnames(df_limpio) == "Frecuencia") - 1
tabla <- DT::datatable(
shared_df,
rownames = FALSE,
filter = "none",
options = base::list(
pageLength = 150,
dom = "ft",
scrollX = TRUE,
fixedHeader = TRUE,
autoWidth = TRUE,
order = base::list(base::list(0, "asc"), base::list(1, "asc")),  # Ordenar por la primera columna "Indicador"
columnDefs = base::list(
base::list(
targets= which(colnames(df_limpio) %in% c("year", "segundo_str", "month", "orden_fecha")) - 1,
visible= FALSE
),
base::list(className = "dt-center", targets = "_all"),
base::list(
targets = 3, # columnas de fecha
render = DT::JS(
"function(data, type, row, meta) {",
"  if(type === 'sort') {",
"    if(data === null || data === '' || data === '-') { return '9999-12-31'; }",
"    return data;",
"  }",
"  if(type === 'display') {",
"    if(data === null || data === '') { return '-'; }",
"    var d = new Date(data);",
"    if(isNaN(d)) { return data; }",
"    var day = ('0' + (d.getUTCDate())).slice(-2);",
"    var month = ('0' + (d.getUTCMonth()+1)).slice(-2);",
"    var year = d.getFullYear();",
"    return day + '/' + month + '/' + year;",
"  }",
"  return data;",
"}"
)
),
# base::list(
#   targets = which(colnames(df_limpio) == "orden_fecha") - 1,
#   render = DT::JS(
#     "function(data, type, row, meta) {",
#     "  if (data === null || data === '') { return '-'; }",
#     "  if (type === 'display') {",
#     "    var s = data.toString();",
#     "    if (s.length === 6) {",
#     "      var anio = s.substring(0, 4);",
#     "      var valor = s.substring(4, 6);",
#     "      var frec = row[", idx_frecuencia, "];", # Accedemos a la columna Frecuencia
#     "      ",
#     "      if (frec === 'Mensual') return anio + '.M' + valor;",
#     "      if (frec === 'Trimestral') return anio + '.T' + (parseInt(valor)/3);",
#     "      if (frec === 'Semestral') return anio + '.S' + (parseInt(valor)/6);",
#     "      if (frec === 'Anual' || frec === 'Censal' ) return anio;",
#     "      ",
#     "      return anio + '.' + valor;", # Por si hay otra frecuencia no contemplada
#     "    }",
#     "  }",
#     "  return data;",
#     "}"
#   )
# ),
base::list(
targets = which(colnames(df_limpio) == "Último dato") - 1,
render = DT::JS(
"function(data, type, row, meta) {",
"  if (data === null || data === '') { return '-'; }",
"  if (type === 'display') {",
"    var s = data.toString();",
"    if (s.length === 6) {",
"      var anio = s.substring(0, 4);",
"      var valor = parseInt(s.substring(4, 6));",
"      var frec = row[", idx_frecuencia, "];", # Accedemos a la columna Frecuencia
"      if (frec === 'Mensual') return anio + '.M' + valor;",
"      if (frec === 'Trimestral') return anio + '.T' + (parseInt(valor)/3);",
"      if (frec === 'Semestral') return anio + '.S' + (parseInt(valor)/6);",
"      if (frec === 'Anual' || frec === 'Censal' ) return anio;",
"      ",
"      return anio + '.' + valor;", # Por si hay otra frecuencia no contemplada
"    }",
"  }",
"  return data;",
"}"
)
)
),
language = base::list(
search = "Buscar",
searchPlaceholder = "texto dentro de la tabla",
paginate = base::list(previous = "", `next` = ""),
info = ""
)
),
class = "compact stripe hover"
)
htmlwidgets::saveWidget(
tabla,
file = "tabla.html",
libdir = "tabla_files",
selfcontained = FALSE,    # <---- IMPORTANTE PARA QUE NO ROMPA EL LAYOUT
title = NULL
)
limpiar_widget_html("tabla.html", "tabla.html")
#### CREACION Y SALIDA DE LA FECHA ####
fecha_html <- sprintf(format(Sys.Date(), "%d de %B de %Y"))
writeLines(fecha_html, "templates/update_date.html")
#### INYECCIÓN EN CALENDARIO ####
base::source("templates/injects.r")
